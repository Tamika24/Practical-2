[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Home Page",
    "section": "",
    "text": "Welcome to My Practical Answers\nThank you for visiting! This site contains my solutions for Practical 2, covering key concepts and exercises.\nEach section includes detailed answers, explanations, and code implementations where necessary. Feel free to navigate through the different practicals using the menu above.\n\n\nThe link to Git :\n\n\nhttps://github.com/Tamika24/Practical-2"
  },
  {
    "objectID": "Practical2.html",
    "href": "Practical2.html",
    "title": "Practical 2",
    "section": "",
    "text": "# Load necessary libraries\nlibrary(foreach)\nlibrary(doParallel)\n\nLoading required package: iterators\n\n\nLoading required package: parallel\n\nlibrary(knitr)\n\n# Set up a parallel backend with one fewer than available cores\nncores &lt;- parallel::detectCores() - 1\ncl &lt;- makeCluster(ncores)\nregisterDoParallel(cl)\n\n# Number of simulations and sample size for each simulation\nnum_simulations &lt;- 100\nsample_size &lt;- 100  # you can change this if needed\n\n# Use a foreach loop to run the simulation 100 times\nresults &lt;- foreach(i = 1:num_simulations, .combine = rbind) %dopar% {\n  # Generate a random sample from an exponential distribution with mean = 1\n  sample_data &lt;- rexp(sample_size, rate = 1)\n  \n  # Calculate the mean and variance of the sample\n  sample_mean &lt;- mean(sample_data)\n  sample_variance &lt;- var(sample_data)\n  \n  # Return a vector with the mean and variance\n  c(mean = sample_mean, variance = sample_variance)\n}\n\n# Stop the parallel cluster\nstopCluster(cl)\n\n# Display the first few rows of the results\ncat(\"The results are :\")\n\nThe results are :\n\nresults\n\n                mean  variance\nresult.1   0.8364405 0.7794739\nresult.2   0.8589722 0.7254857\nresult.3   0.8509645 0.5764535\nresult.4   0.8906410 0.5700677\nresult.5   1.1166481 1.6116580\nresult.6   1.1014119 0.9458652\nresult.7   1.0872020 1.2565651\nresult.8   1.0011047 0.9873087\nresult.9   0.9946669 0.8354981\nresult.10  0.9850530 0.9899886\nresult.11  0.9542878 0.7928263\nresult.12  0.8889971 0.7554661\nresult.13  1.1279258 0.9846163\nresult.14  0.9264399 0.8468748\nresult.15  1.0846235 1.5663394\nresult.16  0.9658454 1.1812441\nresult.17  0.9875295 0.8371274\nresult.18  1.0325527 1.2494040\nresult.19  1.2312839 1.2800670\nresult.20  1.0446042 0.7829407\nresult.21  0.9340383 0.8672679\nresult.22  1.1375114 1.1629863\nresult.23  1.0740415 1.1100633\nresult.24  1.1692907 0.8794005\nresult.25  0.8795042 0.7095412\nresult.26  0.8628069 0.6381025\nresult.27  0.9695409 0.8002846\nresult.28  0.9174476 1.1442582\nresult.29  0.9574194 0.7840024\nresult.30  0.9432917 0.7653497\nresult.31  1.1660100 1.6206929\nresult.32  0.8797697 0.7086745\nresult.33  1.0707355 1.3026874\nresult.34  0.8883713 0.8934443\nresult.35  0.8933045 0.7396090\nresult.36  0.8931919 1.0684035\nresult.37  0.9630437 1.1795211\nresult.38  1.1154559 1.2576851\nresult.39  0.9931151 1.0009566\nresult.40  0.8620618 0.7428695\nresult.41  1.0518407 1.1866304\nresult.42  0.9221772 0.8376077\nresult.43  0.8541491 0.8303010\nresult.44  0.9875338 0.8311751\nresult.45  1.0935202 1.4803949\nresult.46  0.9920811 0.7576493\nresult.47  1.2724624 1.8306899\nresult.48  0.9609453 1.0113485\nresult.49  1.0200451 0.7581445\nresult.50  1.0271336 1.5714199\nresult.51  0.8873527 0.7851523\nresult.52  1.0900374 1.1182527\nresult.53  0.9039610 0.7582065\nresult.54  0.9309491 0.8775557\nresult.55  0.9574896 1.0307083\nresult.56  1.1500047 1.3542749\nresult.57  1.0549385 1.3580744\nresult.58  1.0491553 1.5128993\nresult.59  0.7784552 0.8364577\nresult.60  0.9547644 0.9287202\nresult.61  0.9964838 0.9754582\nresult.62  1.0239160 0.9970872\nresult.63  1.1152368 1.1103375\nresult.64  0.9696481 0.9252147\nresult.65  1.2305480 1.7148704\nresult.66  1.0258839 0.9009833\nresult.67  0.8635914 0.6739843\nresult.68  0.7304815 0.5892006\nresult.69  0.9267049 0.8719471\nresult.70  1.2173595 1.0915623\nresult.71  1.1813832 1.0207946\nresult.72  0.9496068 0.7214904\nresult.73  1.1189144 1.9117044\nresult.74  0.9342064 0.9257941\nresult.75  0.9451814 1.0147826\nresult.76  1.0996733 1.1558188\nresult.77  1.3024983 1.6988872\nresult.78  1.0172991 1.2286016\nresult.79  1.1017539 1.4912146\nresult.80  1.0874351 0.9276264\nresult.81  1.0172593 1.0822142\nresult.82  1.3044575 2.1143949\nresult.83  1.1205259 0.9914771\nresult.84  1.0644210 1.2759267\nresult.85  1.0036462 0.8509396\nresult.86  1.0006856 0.9672426\nresult.87  1.0682444 1.2026364\nresult.88  0.9753149 1.0352844\nresult.89  1.0935575 1.0109794\nresult.90  1.0796939 0.9055272\nresult.91  0.8593820 0.6920229\nresult.92  0.9361828 0.9698284\nresult.93  0.9149357 0.5548983\nresult.94  0.9351805 0.8884117\nresult.95  0.9351701 0.8703587\nresult.96  0.8685491 0.8138875\nresult.97  1.1028720 1.5612941\nresult.98  0.9121402 0.9500297\nresult.99  1.1985575 1.9315565\nresult.100 1.1325941 1.2348922"
  },
  {
    "objectID": "Practical2.html#question-1",
    "href": "Practical2.html#question-1",
    "title": "Practical 2",
    "section": "",
    "text": "# Load necessary libraries\nlibrary(foreach)\nlibrary(doParallel)\n\nLoading required package: iterators\n\n\nLoading required package: parallel\n\nlibrary(knitr)\n\n# Set up a parallel backend with one fewer than available cores\nncores &lt;- parallel::detectCores() - 1\ncl &lt;- makeCluster(ncores)\nregisterDoParallel(cl)\n\n# Number of simulations and sample size for each simulation\nnum_simulations &lt;- 100\nsample_size &lt;- 100  # you can change this if needed\n\n# Use a foreach loop to run the simulation 100 times\nresults &lt;- foreach(i = 1:num_simulations, .combine = rbind) %dopar% {\n  # Generate a random sample from an exponential distribution with mean = 1\n  sample_data &lt;- rexp(sample_size, rate = 1)\n  \n  # Calculate the mean and variance of the sample\n  sample_mean &lt;- mean(sample_data)\n  sample_variance &lt;- var(sample_data)\n  \n  # Return a vector with the mean and variance\n  c(mean = sample_mean, variance = sample_variance)\n}\n\n# Stop the parallel cluster\nstopCluster(cl)\n\n# Display the first few rows of the results\ncat(\"The results are :\")\n\nThe results are :\n\nresults\n\n                mean  variance\nresult.1   0.8364405 0.7794739\nresult.2   0.8589722 0.7254857\nresult.3   0.8509645 0.5764535\nresult.4   0.8906410 0.5700677\nresult.5   1.1166481 1.6116580\nresult.6   1.1014119 0.9458652\nresult.7   1.0872020 1.2565651\nresult.8   1.0011047 0.9873087\nresult.9   0.9946669 0.8354981\nresult.10  0.9850530 0.9899886\nresult.11  0.9542878 0.7928263\nresult.12  0.8889971 0.7554661\nresult.13  1.1279258 0.9846163\nresult.14  0.9264399 0.8468748\nresult.15  1.0846235 1.5663394\nresult.16  0.9658454 1.1812441\nresult.17  0.9875295 0.8371274\nresult.18  1.0325527 1.2494040\nresult.19  1.2312839 1.2800670\nresult.20  1.0446042 0.7829407\nresult.21  0.9340383 0.8672679\nresult.22  1.1375114 1.1629863\nresult.23  1.0740415 1.1100633\nresult.24  1.1692907 0.8794005\nresult.25  0.8795042 0.7095412\nresult.26  0.8628069 0.6381025\nresult.27  0.9695409 0.8002846\nresult.28  0.9174476 1.1442582\nresult.29  0.9574194 0.7840024\nresult.30  0.9432917 0.7653497\nresult.31  1.1660100 1.6206929\nresult.32  0.8797697 0.7086745\nresult.33  1.0707355 1.3026874\nresult.34  0.8883713 0.8934443\nresult.35  0.8933045 0.7396090\nresult.36  0.8931919 1.0684035\nresult.37  0.9630437 1.1795211\nresult.38  1.1154559 1.2576851\nresult.39  0.9931151 1.0009566\nresult.40  0.8620618 0.7428695\nresult.41  1.0518407 1.1866304\nresult.42  0.9221772 0.8376077\nresult.43  0.8541491 0.8303010\nresult.44  0.9875338 0.8311751\nresult.45  1.0935202 1.4803949\nresult.46  0.9920811 0.7576493\nresult.47  1.2724624 1.8306899\nresult.48  0.9609453 1.0113485\nresult.49  1.0200451 0.7581445\nresult.50  1.0271336 1.5714199\nresult.51  0.8873527 0.7851523\nresult.52  1.0900374 1.1182527\nresult.53  0.9039610 0.7582065\nresult.54  0.9309491 0.8775557\nresult.55  0.9574896 1.0307083\nresult.56  1.1500047 1.3542749\nresult.57  1.0549385 1.3580744\nresult.58  1.0491553 1.5128993\nresult.59  0.7784552 0.8364577\nresult.60  0.9547644 0.9287202\nresult.61  0.9964838 0.9754582\nresult.62  1.0239160 0.9970872\nresult.63  1.1152368 1.1103375\nresult.64  0.9696481 0.9252147\nresult.65  1.2305480 1.7148704\nresult.66  1.0258839 0.9009833\nresult.67  0.8635914 0.6739843\nresult.68  0.7304815 0.5892006\nresult.69  0.9267049 0.8719471\nresult.70  1.2173595 1.0915623\nresult.71  1.1813832 1.0207946\nresult.72  0.9496068 0.7214904\nresult.73  1.1189144 1.9117044\nresult.74  0.9342064 0.9257941\nresult.75  0.9451814 1.0147826\nresult.76  1.0996733 1.1558188\nresult.77  1.3024983 1.6988872\nresult.78  1.0172991 1.2286016\nresult.79  1.1017539 1.4912146\nresult.80  1.0874351 0.9276264\nresult.81  1.0172593 1.0822142\nresult.82  1.3044575 2.1143949\nresult.83  1.1205259 0.9914771\nresult.84  1.0644210 1.2759267\nresult.85  1.0036462 0.8509396\nresult.86  1.0006856 0.9672426\nresult.87  1.0682444 1.2026364\nresult.88  0.9753149 1.0352844\nresult.89  1.0935575 1.0109794\nresult.90  1.0796939 0.9055272\nresult.91  0.8593820 0.6920229\nresult.92  0.9361828 0.9698284\nresult.93  0.9149357 0.5548983\nresult.94  0.9351805 0.8884117\nresult.95  0.9351701 0.8703587\nresult.96  0.8685491 0.8138875\nresult.97  1.1028720 1.5612941\nresult.98  0.9121402 0.9500297\nresult.99  1.1985575 1.9315565\nresult.100 1.1325941 1.2348922"
  },
  {
    "objectID": "Practical2.html#question-2",
    "href": "Practical2.html#question-2",
    "title": "Practical 2",
    "section": "Question 2",
    "text": "Question 2\n\n# Load necessary libraries\nlibrary(MASS)         # For galaxies data\nlibrary(doParallel)   # For parallel backend\nlibrary(foreach)      # For the foreach loop\n\n# Load the galaxies data\ndata(galaxies)\n\n# Set the number of bootstrap samples\nn_boot &lt;- 10000\n\n# Serial Bootstrapping\nset.seed(123)\nserial_time &lt;- system.time({\n  boot_medians_serial &lt;- replicate(n_boot, {\n    sample_data &lt;- sample(galaxies, replace = TRUE)\n    median(sample_data)\n  })\n})\ncat(\"Serial processing time:\\n\")\n\nSerial processing time:\n\nprint(serial_time)\n\n   user  system elapsed \n  0.557   0.013   0.571 \n\n# Parallel Bootstrapping: One Bootstrap per Iteration\n# Set up parallel backend\nncores &lt;- parallel::detectCores() - 1\ncl &lt;- makeCluster(ncores)\nregisterDoParallel(cl)\n\nset.seed(123)\nparallel_time &lt;- system.time({\n  boot_medians_parallel &lt;- foreach(i = 1:n_boot, .packages = 'MASS') %dopar% {\n    sample_data &lt;- sample(galaxies, replace = TRUE)\n    median(sample_data)\n  }\n})\ncat(\"Parallel processing time (one bootstrap per iteration):\\n\")\n\nParallel processing time (one bootstrap per iteration):\n\nprint(parallel_time)\n\n   user  system elapsed \n  2.663   0.242   3.086 \n\n# Parallel Bootstrapping: 1000 Bootstraps per Iteration (Chunking)\n# Determine number of chunks\nchunk_size &lt;- 1000\nn_chunks &lt;- n_boot / chunk_size  # here, 10 chunks if n_boot = 10000\n\nset.seed(123)\nchunk_parallel_time &lt;- system.time({\n  boot_medians_chunk &lt;- foreach(i = 1:n_chunks, .packages = 'MASS', .combine = c) %dopar% {\n    # For each chunk, perform 1000 bootstrap samples\n    sapply(1:chunk_size, function(j) {\n      sample_data &lt;- sample(galaxies, replace = TRUE)\n      median(sample_data)\n    })\n  }\n})\ncat(\"Parallel processing time (1000 bootstraps per iteration):\\n\")\n\nParallel processing time (1000 bootstraps per iteration):\n\nprint(chunk_parallel_time)\n\n   user  system elapsed \n  0.010   0.002   0.204 \n\n# Shut down the cluster\nstopCluster(cl)\n\nWhen each iteration is very quick (like a single bootstrap), parallel processing can add significant overhead and actually slow down the computation. However, when you increase the work per iteration (e.g., 1000 bootstraps per iteration), the computational load becomes large enough relative to the overhead that parallel processing offers a substantial speedup over serial processing."
  },
  {
    "objectID": "Practical2.html#question-3",
    "href": "Practical2.html#question-3",
    "title": "Practical 2",
    "section": "Question 3",
    "text": "Question 3\n\n# Set simulation parameters\nset.seed(123)        # For reproducibility\nn &lt;- 50              # Sample size\nM &lt;- 1000            # Number of simulation iterations\nB &lt;- 1000            # Number of bootstrap replicates per iteration\n\n# Vector to record if the CI covers the true mean (1) for each simulation\ncoverage &lt;- numeric(M)\n\nfor(i in 1:M) {\n  # Draw a sample of size 50 from an exponential distribution (mean = 1)\n  sample_data &lt;- rexp(n, rate = 1)\n  \n  # Bootstrap: compute the mean for B bootstrap samples\n  boot_means &lt;- replicate(B, mean(sample(sample_data, size = n, replace = TRUE)))\n  \n  # Compute the 95% percentile bootstrap confidence interval\n  ci &lt;- quantile(boot_means, probs = c(0.025, 0.975))\n  \n  # Check if the true mean (1) falls within the CI\n  coverage[i] &lt;- as.numeric( (1 &gt;= ci[1]) & (1 &lt;= ci[2]) )\n}\n\n# Calculate the coverage probability\ncoverage_probability &lt;- mean(coverage)\ncat(\"Estimated coverage probability:\", coverage_probability, \"\\n\")\n\nEstimated coverage probability: 0.916"
  },
  {
    "objectID": "Practical2.html#question-4",
    "href": "Practical2.html#question-4",
    "title": "Practical 2",
    "section": "Question 4",
    "text": "Question 4\n\nlibrary(doParallel)\nlibrary(foreach)\nlibrary(iterators)\n\nset.seed(1234)\n\n# Set up a parallel backend using available cores\ncl &lt;- makeCluster(detectCores() - 1)\nregisterDoParallel(cl)\n\n# Use foreach: for each iteration (1:3), create an iterator for one vector of 5 normals,\n# extract the vector, and compute its maximum.\nresults &lt;- foreach(i = 1:3, .combine = c, .packages = \"iterators\") %dopar% {\n  vec_iter &lt;- irnorm(1, n = 5)  # returns an iterator for 1 vector\n  vec &lt;- nextElem(vec_iter)     # extract the numeric vector from the iterator\n  max(vec)                     # compute the maximum value\n}\n\n# Stop the cluster\nstopCluster(cl)\n\n# Print the results\nprint(results)\n\n[1] 1.757206 4.181174 1.403989\n\n\n##Question 5\n\n# -----------------------\n# Setup\n# -----------------------\nlibrary(iterators)\nlibrary(foreach)\nlibrary(doParallel)\nlibrary(parallel)\n\n# Define parameters\nnum_iter &lt;- 3  # Number of vectors to generate\nn &lt;- 5         # Number of random normals per vector\n\n# Set the seed for reproducibility\nset.seed(1234)\n\n# -----------------------\n# Method 1: Using parLapply (Parallel)\n# -----------------------\n# Create a parallel cluster\ncl1 &lt;- makeCluster(detectCores() - 1)\n\n# Export the variable 'n' to the cluster and load 'iterators' on each worker\nclusterExport(cl1, varlist = \"n\")\nc &lt;- clusterEvalQ(cl1, library(iterators))\n\n# Measure time for parLapply\nparLapply_time &lt;- system.time({\n  parLapply_results &lt;- parLapply(cl1, 1:num_iter, function(i) {\n    # Create an iterator for one vector of n random normals\n    vec_iter &lt;- irnorm(1, n = n)\n    # Extract the numeric vector from the iterator\n    vec &lt;- nextElem(vec_iter)\n    # Return the maximum value from the vector\n    max(vec)\n  })\n  parLapply_results &lt;- unlist(parLapply_results)\n})\nstopCluster(cl1)  # Shut down the cluster\n\n# -----------------------\n# Method 2: Using foreach with %dopar% (Parallel)\n# -----------------------\ncl2 &lt;- makeCluster(detectCores() - 1)\nregisterDoParallel(cl2)\n\n# Measure time for foreach; export 'n' and load the 'iterators' package on each worker.\nforeach_time &lt;- system.time({\n  foreach_results &lt;- foreach(i = 1:num_iter, .combine = c,\n                             .packages = \"iterators\",\n                             .export = \"n\") %dopar% {\n    vec_iter &lt;- irnorm(1, n = n)\n    vec &lt;- nextElem(vec_iter)\n    max(vec)\n  }\n})\n\nWarning in e$fun(obj, substitute(ex), parent.frame(), e$data): already\nexporting variable(s): n\n\nstopCluster(cl2)\n\n# -----------------------\n# Method 3: Using replicate (Sequential)\n# -----------------------\nreplicate_time &lt;- system.time({\n  replicate_results &lt;- replicate(num_iter, {\n    vec_iter &lt;- irnorm(1, n = n)\n    vec &lt;- nextElem(vec_iter)\n    max(vec)\n  })\n})\n\n# -----------------------\n# Print the results and timing comparisons\n# -----------------------\ncat(\"Results and timings:\\n\\n\")\n\nResults and timings:\n\ncat(\"parLapply results:\\n\")\n\nparLapply results:\n\nprint(parLapply_results)\n\n[1] 1.935221 2.232250 2.135141\n\nprint(parLapply_time)\n\n   user  system elapsed \n  0.003   0.000   0.005 \n\ncat(\"\\nforeach (%dopar%) results:\\n\")\n\n\nforeach (%dopar%) results:\n\nprint(foreach_results)\n\n[1] 3.017940 1.278907 2.417294\n\nprint(foreach_time)\n\n   user  system elapsed \n  0.009   0.001   0.050 \n\ncat(\"\\nreplicate results:\\n\")\n\n\nreplicate results:\n\nprint(replicate_results)\n\n[1] 2.084441 1.506056 1.959494\n\nprint(replicate_time)\n\n   user  system elapsed \n  0.004   0.001   0.004"
  }
]